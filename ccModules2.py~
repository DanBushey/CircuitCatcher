import numpy as np
import pandas as pd
from skimage.draw import polygon #used in roi creation
import dask
import dask.array as da
from dask import delayed
from numba import jit




def convertZXYtoMask(ZXY, image_shape):
    '''
    convert X Y Z points as drawn by a polygon into an index given the image_shape
    XYZ = dictionary with keys as layers and data as XY points
    img_shape = image shape generated by image.shape
    '''
    mask = np.zeros([image_shape[1], image_shape[3], image_shape[2]], dtype = np.bool) #believe I messed up x and y coordinates and now must reverse here to make compatible with later roi scripts
    for layer in ZXY.keys():
        if len(ZXY[layer]) == 1: #roi consist has only one X,Y point
            mask[layer, int(np.rint(ZXY[layer][0][0])), int(np.rint(ZXY[layer][0][1]))] = 1
        else:
            xy =  ZXY[layer]
            xy = np.vstack(xy)
            xx, yy = polygon(xy[: , 0], xy[: , 1])
            mask[layer,  yy, xx] = 1
    mask = np.where(mask.flatten())
    return mask
    



def pyqt_set_trace():
    '''Set a tracepoint in the Python debugger that works with Qt'''
    from PyQt5.QtCore import pyqtRemoveInputHook
    import pdb
    import sys
    pyqtRemoveInputHook()
    # set up the debugger
    debugger = pdb.Pdb()
    debugger.reset()
    # custom next to get outside of function scope
    debugger.do_next(None) # run the next command
    users_frame = sys._getframe().f_back # frame where the user invoked `pyqt_set_trace()`
    debugger.interaction(users_frame, None)



@jit
def getIntensity(mask_index, image):
    '''
    get raw fluorescence data over each frame in timeseries
    mask_index = index of the desired pixels in image
    image = np.array containing image data
    '''
    image = da.from_array(image, chunks=10000000)
    #get minimum square that includes mask, pulling out minimum sequence reduces time
    mask = generateMask(mask_index, image.shape)
    coord = getMaskRange(mask_index, image.shape)
    mask = mask[coord[0]:coord[1]+1, coord[2]:coord[3]+1, coord[4]:coord[5]+1]
    index2 = np.where(mask)
    #get minimum image coordinates
    image1 = image[:, coord[0]: coord[1]+1, coord[4] : coord[5]+1, coord[2] : coord[3]+1, 0]
    image1 = np.rollaxis(image1, 3,2)
    image1 = image1.compute()
    intensity_data = []
    for time in range(image1.shape[0]):
        intensity_data.append(image1[time, :, :, :][index2].mean())
    return intensity_data

    
def loadTimeSeries(frameTiffFiles):
    '''
    Based on
    http://dask.pydata.org/en/latest/array-creation.html
    loads timeseries data tif image files into an array
    '''


def generateMask(mask_index, image_shape):
    '''
    generate a binary 3d mask corresponding to the roi
    mask_index = index from flattened image
    image_shape = t, z,x,y, c image shape
    '''
    mask = np.zeros(image_shape[1:4], dtype = np.bool)
    mask.flat[mask_index] = True
    return mask
    
def getMaskRange(mask_index, image_shape):
    '''
    get max and min values for z y x
    mask_index = index from flattened image
    image_shape = t, z,x,y, c image shape
    '''
    mask = generateMask(mask_index, image_shape)
    non_zero = np.where(mask ==1)
    max_x = np.max(non_zero[1])
    max_y = np.max(non_zero[2])
    min_x = np.min(non_zero[1])
    min_y = np.min(non_zero[2])
    max_z = np.max(non_zero[0])
    min_z = np.min(non_zero[0])
    return [min_z, max_z, min_x, max_x, min_y, max_y]
    
def cropTZXYCimage(image, coordTZXYC):
    '''
    crop an image using z, x, y coordinates (coord)
    image = t, z, x y, c
    coord = [min_z, max_z, min_x, max_x, min_y, max_y]
    '''
    return image[coordZXY[0]:coordZXY[1]+1,coordZXY[2]:coordZXY[3]+1,coordZXY[4]:coordZXY[5]+1,coordZXY[6]:coordZXY[7]+1,coordZXY[8]:coord[9]+1]
    
    
